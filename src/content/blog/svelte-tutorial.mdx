---
title: 'Svelte 教程'
description: ''
date: '2025-11-04'
---

## SSG vs SSR

- SSG: 当你运行 `npm run build` 这样的构建命令时，框架会预先为你的每一个页面生成一个独立的、完整的 HTML 文件。这些文件是静态的，不包含任何动态逻辑
- SSR: 服务器在接收到用户的页面请求后，会实时地获取最新的数据，渲染出完整的 HTML 页面，然后返回给浏览器。

## 元素InView的时候才进行动画效果

Svelte内置的 `transition:fly` 必须配置 `{#if}` 来实现动画效果。也就是当元素满足某种条件的时候，才进行动画效果。

最开始通过 `IntersectionObserver` 来实现 InView 的状态。这样元素出现在视图中的时候，就能有动画效果了。

但是当多个InView动画元素堆叠在一起的时候，比如下面这样

```Svelte
<div>
  {#if isInView}
    <div transition:fly={{y: 20, duration: 500}}>InView 元素1</div>
  {/if}
</div>
<div>
  {#if isInView}
	  <div transition:fly={{y: 20, duration: 500}}>InView 元素1</div>
  {/if}
</div>
```

虽然说这样有了动画效果，但是由于isInView为false的时候，元素没有被渲染, 外层元素的高度为0，导致后面不该出现在视图中的元素出现在视图中了，提前进行了动画效果。这个是我不想要的。

我看到 Action 和 Attachment, 可以实现 InView 的效:

```Svelte
export const inViewFly = (options?: InViewFlyOptions): Attachment<HTMLDivElement> => {
  const {
    y = 20,
    x = 0,
    scale = 1,
    rotate = 0,
    duration = 500,
    easing = "ease-out",
    delay = 0,
  } = options || {};

  let hasIntersected = $state(false); // 记录是否已经交叉过

  return (element) => {
    const observer = new IntersectionObserver(([entry]) => {
      // 一旦进入视口，就标记为已交叉
      if (entry.isIntersecting) {
        hasIntersected = true;
      }
    }, options);

    observer.observe(element);

    element.style.opacity = hasIntersected ? "1" : "0"
    element.style.transform = hasIntersected ? "translate(0, 0) scale(1) rotate(0deg)" : `translate(${x}px, ${y}px) scale(${scale}) rotate(${rotate}deg)`
    element.style.transition = `all ${duration}ms ${easing} ${delay}ms`;

    return () => {
      observer.disconnect();
    }
  }
}
```

## 全局State

## 动态css

动态实现delay: Tailwind 处理静态和可预测的样式，让 style: 指令处理真正动态的值。两者配合使用才能发挥最大效能！🚀

```css
style="--delay: {i * 50}ms; transition-delay: var(--delay);"
```
